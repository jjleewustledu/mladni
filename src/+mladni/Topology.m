classdef Topology < handle    
    %% A sheaf subordinate to the cover of open sets assigns an abelian group to every non-empty
    %  intersection of cover elements (Ghrist, Elem. Appl. Top., pg. 190);
    %  Loring Tu on graph of a good cover:  https://www.youtube.com/watch?v=BK3VO_1jWqA @ 2:30
    %  "de Rham cohomology depends only on the simplicial complex generated by the Nerve"
    %  
    %  Created 29-Jul-2024 22:50:15 by jjlee in repository /Users/jjlee/MATLAB-Drive/mladni/src/+mladni.
    %  Developed on Matlab 24.1.0.2653294 (R2024a) Update 5 for MACA64.  Copyright 2024 John J. Lee.
    
    properties
        mask
        Nmask
    end

    methods  %% GET
        function g = get.mask(this)
            if ~isempty(this.mask_)
                g = this.mask_;
                return
            end

            g = mlfourd.ImagingContext2( ...
                fullfile(getenv("SINGULARITY_HOME"), "ADNI", "VolBin", "mask.nii.gz"));
            this.mask_ = g;
        end
        function g = get.Nmask(this)
            g = dipsum(this.mask.binarized);  % ~228483
        end
    end

    methods
        function ic = Basis_alluvial_brain_mask(this, opts)
            arguments
                this mladni.Topology
                opts.model_rank {mustBeNumeric} = 24
            end
            ic = mlfourd.ImagingContext2( ...
                fullfile(this.niiImgDir(num_bases=opts.model_rank), "Basis_alluvial_brain_mask.nii"));
        end

        function ic_accum = call_nsimplices(this, n_bases, n_accum, opts)
            %% \sim (
            %    \sum_{i \in \binomial{n}{k}} 
            %      p_{1,i}\qty(\mathbf{x}) \circledot \ldots \circledot p_{i,k}\qty(\mathbf(x))
            %  )^{1/k}

            arguments
                this mladni.Topology
                n_bases {mustBeScalarOrEmpty} = 24
                n_accum {mustBeScalarOrEmpty} = 24
                opts.use_geom_mean logical = true
                opts.tag {mustBeTextScalar} = "geomean-strict"
                opts.to_ignore {mustBeNumeric} = []  % white matter is [20]
            end
            if ~isempty(opts.to_ignore)
                opts.tag = opts.tag + "-" + strrep(num2str(opts.to_ignore), " ", ",");
            end

            ic_accum = this.patterns(num_bases=n_bases);
            ic_accum = zeros(sum(ic_accum, 4));
            
            for n = 2:n_accum  % singlets have no overlap
                fprintf("num_simplices = %i\n", n)
                try
                    % patterns_nsimplices() has less cortical contrast than patterns_nsimplices_strict()
                    ic = this.patterns_nsimplices_strict( ...
                        num_bases=n_bases, num_simplices=n, ...
                        use_geom_mean=opts.use_geom_mean, to_ignore=opts.to_ignore, tag=opts.tag);
                    ic.save();  % debugging

                    ic_accum = ic_accum + ic;
                catch ME
                    handwarning(ME)
                end
            end
            if opts.use_geom_mean  % retain magnitudes of original patterns
                ic_accum = ic_accum / n_accum;
            end
            ic_accum.fileprefix = sprintf("%s_nbases=%i_naccum=%i_%s", stackstr(), 24, n, opts.tag);
            ic_accum.save(); 
        end

        function d = numBasesDir(this, opts)
            arguments
                this mladni.Topology
                opts.num_bases int16 = 24
            end

            d = fullfile(getenv("SINGULARITY_HOME"), ...
                "ADNI", "NMF_FDG", "baseline_cn", "NumBases" + opts.num_bases);
        end

        function d = niiImgDir(this, opts)
            arguments
                this mladni.Topology
                opts.num_bases int16 = 24
            end

            d = fullfile(getenv("SINGULARITY_HOME"), ...
                "ADNI", "NMF_FDG", "baseline_cn", "NumBases" + opts.num_bases, "OPNMF", "niiImg");
        end
        
        function C = covariance(this, opts)
            arguments
                this mladni.Topology
                opts.model_rank {mustBeNumeric} = 24
                opts.do_plot logical = true
                opts.do_save logical = true
                opts.try_alluvial logical = true
                opts.do_diag logical = false
            end

            max_rank = 24;

            % labels for heatmaps should be consistent with alluvials
            pids = this.patterns_ids( ...
                patterns=this.Basis_alluvial_brain_mask(model_rank=opts.model_rank), ...
                patterns_ref=this.Basis_alluvial_brain_mask(model_rank=max_rank));
            [~,sorting] = sort(pids);
            labels = "p"+pids(sorting);

            % C
            pp = this.patterns(num_bases=opts.model_rank, try_alluvial=opts.try_alluvial);
            pp = pp.imagingFormat;
            C = zeros(opts.model_rank, opts.model_rank);
            for p1 = 1:opts.model_rank
                for p2 = 1:opts.model_rank                    
                    C(p1, p2) = dipsum(sqrt(pp.img(:,:,:,p1).*pp.img(:,:,:,p2)));
                end
            end
            C = C(sorting, sorting);

            % C units -> encoding/microliter
            C = C/prod(pp.mmppix);
            
            % C diag <- NaN to emphasize interpattern overlaps
            if ~opts.do_diag
                C(eye(size(C)) == 1) = NaN;
            end

            if opts.do_plot
                min_rank = 6;  % make no plot smaller than that for opts.model_rank == min_rank
                this.heatmap(C, labels=labels);
                if opts.model_rank >= min_rank
                    this.set_gcf(fracx=0.8*opts.model_rank/max_rank, fracy=0.9236*opts.model_rank/max_rank);
                else
                    this.set_gcf(fracx=0.8*min_rank/max_rank, fracy=0.9236*min_rank/max_rank);
                end
            end

            if opts.do_save
                fqfp = fullfile(this.numBasesDir(num_bases=opts.model_rank), stackstr());
                if opts.do_diag
                    fqfp = fqfp + "_dodiag";
                end
                pwd0 = pushd(myfileparts(fqfp));
                saveFigure2(gcf, fqfp);
                popd(pwd0)
                save(fqfp+".mat", "C");                
            end
        end

        function ids = patterns_ids(this, opts)
            arguments
                this mladni.Topology
                opts.patterns {mustBeNonempty}  % 4d patterns
                opts.patterns_ref {mustBeNonempty}  % 4d patterns
            end

            msk = logical(this.mask);
            Nxyz = numel(msk);
            msk1d = reshape(msk, [Nxyz, 1]);

            ic = mlfourd.ImagingContext2(opts.patterns);
            img = reshape(single(ic), [Nxyz, size(ic,4)]);
            img = img(msk1d, :);  % 228483 x Nt
            Nt = size(img, 2);

            ic_ref = mlfourd.ImagingContext2(opts.patterns_ref);
            img_ref = reshape(single(ic_ref), [Nxyz, size(ic_ref,4)]);
            img_ref = img_ref(msk1d, :);  % 228483 x Nt
            Nt_ref = size(img_ref, 2);
            
            assert(Nt_ref >= Nt)  % patterns_ref should provide unique ids

            ids = nan(1, Nt);
            for t = 1:Nt

                similarities = nan(1, Nt_ref);
                for t_ref = 1:Nt_ref
                    similarities(t_ref) = this.cosine_similarity( ...
                        [asrow(img_ref(:,t_ref)); asrow(img(:,t))]);
                end

                [~,t_ref_matched] = max(similarities);  % check similarity to each of Nt_ref patterns_ref
                ids(t) = t_ref_matched;
            end
        end

        function ic = patterns(this, opts)
            %% Returns imaging context for Basis_alluvial_brain_mask.nii if available, else Basis_all.nii

            arguments
                this mladni.Topology
                opts.num_bases int16 = 24
                opts.do_checks logical = false
                opts.try_alluvial logical = true
                opts.to_ignore {mustBeNumeric} = []  % white matter is [20]
            end

            if opts.try_alluvial
                ic = mlfourd.ImagingContext2( ...
                    fullfile(this.niiImgDir(num_bases=opts.num_bases), "Basis_alluvial_brain_mask.nii"));
                if ~isfile(ic.fqfn)
                    warning("mladni:ValueWarning", stackstr() + ": Basis_alluvial_brain_mask not found")
                    ic = mlfourd.ImagingContext2( ...
                        fullfile(this.niiImgDir(num_bases=opts.num_bases), "Basis_all.nii"));
                end
            else
                ic = mlfourd.ImagingContext2( ...
                    fullfile(this.niiImgDir(num_bases=opts.num_bases), "Basis_all.nii"));
            end
            assert(isfile(ic.fqfn))

            if opts.do_checks
                this.check_sum_max(ic);
            end
            if ~isempty(opts.to_ignore)
                ifc = ic.imagingFormat;
                sz = size(ifc.img);
                ifc.img(:,:,:,opts.to_ignore) = ones(sz(1), sz(2), sz(3), length(opts.to_ignore));
                ic = mlfourd.ImagingContext2(ifc);
            end
        end

        function ic = patterns2logp(this, opts)
            %% Open sets in the topological space will be represented by prob over the MNI brain,
            %  renornalized by uniform distrib. ~ 1/numel(mask)
            %  Pattern indices are by rank of SUVR of pattern-weighted averages of ADNI FDG.

            arguments
                this mladni.Topology
                opts.num_bases int16 = 24
                opts.do_save logical = false
                opts.do_checks logical = true
                opts.use_cache logical = true
                opts.use_prob_per_voxel logical = false
            end

            if opts.use_cache
                fqfn = fullfile(this.niiImgDir(num_bases=opts.num_bases), stackstr() + ".nii");
                if isfile(fqfn)
                    ic = mlfourd.ImagingContext2(fqfn);
                    return
                end
            end

            all = this.patterns(num_bases=opts.num_bases);
            all_ifc = all.imagingFormat;
            for t = 1:opts.num_bases
                all_ifc.img(:,:,:,t) = log(all_ifc.img(:,:,:,t)) - log(sum(all_ifc.img(:,:,:,t), "all"));
            end
            if opts.use_prob_per_voxel
                all_ifc.img = log(this.Nmask) + all_ifc.img;
            end
            ic = mlfourd.ImagingContext2(all_ifc);
            ic.fileprefix = stackstr(use_underscores=true);
            if opts.do_save
                ic.save();
            end

            if opts.do_checks
                this.check_sum_max(all_ifc);
            end
        end

        function ic = patterns2probabilities(this, opts)
            %% Open sets in the topological space will be represented by prob over the MNI brain;
            %  Pattern indices are by rank of SUVR of pattern-weighted averages of ADNI FDG.

            arguments
                this mladni.Topology
                opts.num_bases int16 = 24
                opts.do_save logical = false
                opts.do_checks logical = true
                opts.use_cache logical = true
                opts.use_prob_per_voxel logical = false
            end

            if opts.use_cache
                fqfn = fullfile(this.niiImgDir(num_bases=opts.num_bases), stackstr() + ".nii");
                if isfile(fqfn)
                    ic = mlfourd.ImagingContext2(fqfn);
                    return
                end
                if ~isempty(this.pattern_probabilities_)
                    ic = copy(this.pattern_probabilities_);
                    return
                end
            end

            all = this.patterns(num_bases=opts.num_bases);
            all_ifc = all.imagingFormat;
            for t = 1:opts.num_bases
                all_ifc.img(:,:,:,t) = all_ifc.img(:,:,:,t)/sum(all_ifc.img(:,:,:,t), "all");
            end
            if opts.use_prob_per_voxel
                all_ifc.img = this.Nmask*all_ifc.img;
            end
            ic = mlfourd.ImagingContext2(all_ifc);
            ic.fileprefix = stackstr(use_underscores=true);
            this.pattern_probabilities_ = ic;
            if opts.do_save
                ic.save();
            end

            if opts.do_checks
                this.check_sum_max(all_ifc);
            end
        end

        function ic = patterns_edges(this, opts)
            %% 1-simplex for overlap of vertex_0 & vertex_1

            arguments
                this mladni.Topology
                opts.num_bases int16 = 2
                opts.select {mustBeNumeric} = []
                opts.do_contract logical = true
                opts.do_normalize logical = true
            end
            if isempty(opts.select)
                opts.select = 1:opts.num_bases;
            end

            pp = this.patterns(num_bases=opts.num_bases);
            pp = pp.imagingFormat;
            sz = size(pp);
            img = zeros(sz);

            for nidx = opts.select
                img_node = pp.img(:,:,:, nidx);
                % median_node = median(img_node(img_node > eps), "all");
                % img_node = img_node/median_node;  % normalize to resemble SUVR
                img_edge = zeros(sz(1:3));  % accumulator
                for eidx = opts.select
                    if eidx ~= nidx
                        % accumulate intersection of node with other patterns -> edge
                        img_edge = img_edge + sqrt(img_node.*pp.img(:,:,:, eidx));
                    end
                end
                img(:,:,:, nidx) = img_edge;
            end

            pp.img = img;
            pp.fileprefix = stackstr();
            ic = mlfourd.ImagingContext2(pp);

            if opts.do_contract
                fp = ic.fileprefix + "_contract";
                ic = ic.timeContracted/length(opts.select);
                ic.fileprefix = fp;
            end

            if opts.do_normalize
                fp = ic.fileprefix;
                ic = ic/dipmax(ic);
                ic.fileprefix = fp;
            end
        end

        function ic = patterns_faces(this, opts)
            %% 2-simplex for overlap of vertex_0, vertex_1, vertex_2

            arguments
                this mladni.Topology
                opts.num_bases int16 = 2
                opts.select {mustBeNumeric} = []
                opts.do_contract logical = true
                opts.do_normalize logical = true
            end
            if isempty(opts.select)
                opts.select = 1:opts.num_bases;
            end

            pp = this.patterns(num_bases=opts.num_bases);
            pp = pp.imagingFormat;
            sz = size(pp);
            img = zeros(sz);

            for nidx = opts.select
                img_node = pp.img(:,:,:, nidx);
                % median_node = median(img_node(img_node > eps), "all");
                % img_node = img_node/median_node;  % normalize to resemble SUVR
                img_face = zeros(sz(1:3));  % accumulator
                for eidx = opts.select
                    if eidx ~= nidx
                        for fidx = opts.select
                            if fidx ~= nidx && fidx ~= eidx
                                % accumulate intersection of node with other patterns -> edge
                                img_face = img_face + (img_node.*pp.img(:,:,:, eidx).*pp.img(:,:,:, fidx)).^(1/3);
                            end
                        end
                    end
                end
                img(:,:,:, nidx) = img_face;
            end

            pp.img = img;
            pp.fileprefix = stackstr();
            ic = mlfourd.ImagingContext2(pp);

            if opts.do_contract
                fp = ic.fileprefix + "_contract";
                ic = ic.timeContracted/length(opts.select);
                ic.fileprefix = fp;
            end

            if opts.do_normalize
                fp = ic.fileprefix;
                ic = ic/dipmax(ic);
                ic.fileprefix = fp;
            end
        end

        function ic = patterns_3simplices(this, opts)
            %% 3-simplex for overlap of vertex_0, vertex_1, vertex_2, vertex_3

            arguments
                this mladni.Topology
                opts.num_bases int16 = 2
                opts.select {mustBeNumeric} = []
                opts.do_contract logical = true
                opts.do_normalize logical = true
            end
            if isempty(opts.select)
                opts.select = 1:opts.num_bases;
            end

            pp = this.patterns(num_bases=opts.num_bases);
            pp = pp.imagingFormat;
            sz = size(pp);
            img = zeros(sz);

            for nidx = opts.select
                img_node = pp.img(:,:,:, nidx);
                % median_node = median(img_node(img_node > eps), "all");
                % img_node = img_node/median_node;  % normalize to resemble SUVR
                img_vol = zeros(sz(1:3));  % accumulator
                for eidx = opts.select
                    if eidx ~= nidx
                        for fidx = opts.select
                            if fidx ~= nidx && fidx ~= eidx
                                for gidx = opts.select
                                    if gidx ~= nidx && gidx ~= eidx && gidx ~= fidx
                                        img_vol = img_vol + (img_node.*pp.img(:,:,:, eidx).*pp.img(:,:,:, fidx).*pp.img(:,:,:, gidx)).^(1/4);
                                    end
                                end
                            end
                        end
                    end
                end
                img(:,:,:, nidx) = img_vol;
            end

            pp.img = img;
            pp.fileprefix = stackstr();
            ic = mlfourd.ImagingContext2(pp);

            if opts.do_contract
                fp = ic.fileprefix + "_contract";
                ic = ic.timeContracted/length(opts.select);
                ic.fileprefix = fp;
            end

            if opts.do_normalize
                fp = ic.fileprefix;
                ic = ic/dipmax(ic);
                ic.fileprefix = fp;
            end
        end

        function ic = patterns_nsimplices_strict(this, opts)
            %% n-simplex for overlap of vertex_0, vertex_1, ..., vertex_n

            arguments
                this mladni.Topology
                opts.num_bases int16 = 2
                opts.num_simplices int16 = 2
                opts.select {mustBeNumeric} = []  % unused, but preserves API
                opts.do_contract logical = false  % unused, but preserves API
                opts.do_normalize logical = false
                opts.use_geom_mean logical = true
                opts.to_ignore {mustBeNumeric} = []  % white matter is [20]
                opts.tag {mustBeTextScalar} = "geomean-strict"
            end

            % adjustments
            opts.num_simplices = min(opts.num_simplices, opts.num_bases);

            combinations = this.generate_ordered_combinations(opts.num_bases, opts.num_simplices);
            pp = this.patterns(num_bases=opts.num_bases, to_ignore=opts.to_ignore);
            pp = pp.imagingFormat;
            img = zeros(size(sum(pp.img, 4)));

            % loop provides dynamic programming corresponding to ndgrid(),
            % but returning unique combinations, not permutations
            % if size(combinations, 1) > Nlarge
            %     combinations = this.random_sample_rows(combinations, Nlarge);
            % end
            for icombi = 1:size(combinations, 1)
                img = inner_loop(combinations(icombi, :), pp.img, img);
            end

            pp.img = img;
            pp.fileprefix = ...
                sprintf("%s_nbases=%i_naccum=%i_%s", stackstr(), opts.num_bases, opts.num_simplices, opts.tag);
            ic = mlfourd.ImagingContext2(pp);

            if opts.do_normalize
                if dipmax(ic) > eps
                    ic = ic/dipmax(ic);
                end
            end

            %%

            function img_accum = inner_loop(indices, img, img_accum)
                if isscalar(indices)
                    return  % defensive:  must have at least pairwise overlap
                end
                len_indices = length(indices);
                k = len_indices;

                if numel(unique(indices)) == numel(indices)  % defensive:  exclude duplicate indices
                    hadamard_accum = 1;                    
                    for hadamard_idx = 1:len_indices
                        hadamard_accum = hadamard_accum.*img(:,:,:, indices(hadamard_idx));
                    end
                    if opts.use_geom_mean
                        img_accum = img_accum + hadamard_accum.^(1/k);
                    else
                        img_accum = img_accum + hadamard_accum;
                    end
                end
            end
        end

        function ic = patterns_nsimplices(this, opts)
            %% n-simplex for overlap of vertex_0, vertex_1, ..., vertex_n

            arguments
                this mladni.Topology
                opts.num_bases int16 = 2
                opts.num_simplices int16 = 2
                opts.select {mustBeNumeric} = []  % unused, but preserves API
                opts.do_contract logical = false  % unused, but preserves API
                opts.do_normalize logical = false
                opts.use_geom_mean logical = true
                opts.to_ignore {mustBeNumeric} = []  % white matter is [20]
                opts.tag {mustBeTextScalar} = "geomean-strict"
            end

            % adjustments
            opts.num_simplices = min(opts.num_simplices, opts.num_bases);

            combinations = this.generate_ordered_combinations(opts.num_bases, opts.num_simplices);
            pp = this.patterns(num_bases=opts.num_bases, to_ignore=opts.to_ignore);
            pp = pp.imagingFormat;
            img = zeros(size(sum(pp.img, 4)));

            % loop provides dynamic programming corresponding to ndgrid(),
            % but returning unique combinations, not permutations
            % if size(combinations, 1) > Nlarge
            %     combinations = this.random_sample_rows(combinations, Nlarge);
            % end
            for icombi = 1:size(combinations, 1)
                img = inner_loop(combinations(icombi, :), pp.img, img);
            end
            if opts.use_geom_mean
                k = size(combinations, 2);
                img = img.^(1/k);
            end

            pp.img = img;
            pp.fileprefix = ...
                sprintf("%s_nbases=%i_naccum=%i_%s", stackstr(), opts.num_bases, opts.num_simplices, opts.tag);
            ic = mlfourd.ImagingContext2(pp);

            if opts.do_normalize
                if dipmax(ic) > eps
                    ic = ic/dipmax(ic);
                end
            end

            %%

            function img_accum = inner_loop(indices, img, img_accum)
                if isscalar(indices)
                    return  % defensive:  must have at least pairwise overlap
                end
                len_indices = length(indices);
                k = len_indices;

                if numel(unique(indices)) == numel(indices)  % defensive:  exclude duplicate indices
                    hadamard_accum = 1;                    
                    for hadamard_idx = 1:len_indices
                        hadamard_accum = hadamard_accum.*img(:,:,:, indices(hadamard_idx));
                    end
                    img_accum = img_accum + hadamard_accum;
                end
            end
        end

        function ic = patterns_union(this, opts)
            %% nerve is homotopic to union of open subsets (Ghrist, Elem. Appl. Top., pg. 31)

            arguments
                this mladni.Topology
                opts.num_bases int16 = 24
                opts.except double = []
            end

            ic = this.patterns2probabilities(num_bases=opts.num_bases);
            if ~isempty(opts.except)
                ifc = ic.imagingFormat;
                ifc.img(:,:,:, opts.except) = [];
                ic = mlfourd.ImagingContext2(ifc);
            end
            ic = timeContracted(ic); 
            ic = ic/sum(ic, "all");
            ic.fileprefix = stackstr(use_underscores=true);            
            if ~isempty(opts.except)
                ic.fileprefix = ic.fileprefix + "_except" + opts.except;
            end
        end

        function T = table_overlap_with_Margulies(this)
        end

        function T = table_overlap_with_Yeo7(this, obj, yeo_index)
            arguments
                this mladni.Topology
                obj {mustBeNonempty} = "Topology_patterns2probabilities_1mm.nii.gz"
                yeo_index double = 7  % DMN
            end

            ic = mlfourd.ImagingContext2(obj);
            if ~contains(ic.fileprefix, "_1mm")
                ic = mlfourd.ImagingContext2(this.flirt(ic.fqfn));
                assert(contains(ic.fileprefix, "_1mm"))
            end
            assert(isfile(ic.fqfn))

            msk = mlfourd.ImagingContext2( ...
                fullfile(getenv("REFDIR"), "MNI152_T1_1mm_brain_mask.nii.gz"));
            yeodir = fullfile(getenv("REFDIR"), "Yeo");
            yeo7 = mlfourd.ImagingContext2( ...
                fullfile(yeodir, "Yeo2011_7Networks_to_MNI152_T1_1mm.nii.gz"));

            yeo_img = single(yeo7.imagingFormat.img == yeo_index);
            yeo_img = asrow(yeo_img(:));
            ic = ic.masked(msk);
            pattern = ascol(1:size(ic, 4));
            similarity = nan(size(ic, 4), 1);
            for t = asrow(pattern)
                obj_img = ic.imagingFormat.img(:,:,:,t);
                obj_img = asrow(obj_img(:));
                similarity(t) = this.cosine_similarity([yeo_img; obj_img]);
            end

            T = table(pattern, similarity);
            T = sortrows(T, "similarity", "descend");
        end
        
        function view_nerves(this, opts)
            arguments
                this mladni.Topology
                opts.save_niis logical = true
            end

            model_degrees = [2, 6, 8, 10, 12, 14, 24];

            md_idx = 0;
            for model_degree = model_degrees(1:end-1)
                md_idx = md_idx + 1;

                nodes = this.patterns2logp(num_bases=model_degree, do_checks=true);
                % fprintf("%s:  view nodes of %i-model\n", stackstr(), model_degree);
                % nodes.view()

                nodes_next = this.patterns2logp(num_bases=model_degrees(md_idx+1), do_checks=true);
                % fprintf("%s:  view nodes of %i-model\n", stackstr(), model_degrees(md_idx+1));
                % nodes_next.view()
                
                for node_index = 1:model_degree
                    edges = this.node2edges(nodes, node_index=node_index, nodes_next=nodes_next);
                    fprintf("%s:  view %i edges of node %i of %i-model\n", stackstr(), size(edges, 4), node_index, model_degree);
                    % edges.view()
                    if opts.save_niis
                        edges.save(); 
                    end
                end
                
                edges_sumt = mlfourd.ImagingContext2(edges);
                edges_sumt = edges_sumt.timeAveraged();
                edges_sumt.view();
                if opts.save_niis
                    edges_sumt.save();
                end
            end
        end

        function sim_1 = view_dominant_paths(this)
            %% t = mladni.Topology; t.view_dominant_paths
            %
            % t =
            %
            %   Topology with no properties.
            %
            % model degree: 2, alluvial id 11, best next-alluvial id 11, best sim 0.903965
            % model degree: 2, alluvial id 20, best next-alluvial id 20, best sim 0.898907
            %
            % model degree: 6, alluvial id 3, best next-alluvial id 3, best sim 0.989825
            % model degree: 6, alluvial id 11, best next-alluvial id 11, best sim 0.974347
            % model degree: 6, alluvial id 13, best next-alluvial id 13, best sim 0.98936
            % model degree: 6, alluvial id 15, best next-alluvial id 15, best sim 0.987104
            % model degree: 6, alluvial id 16, best next-alluvial id 16, best sim 0.984398
            % model degree: 6, alluvial id 20, best next-alluvial id 20, best sim 0.924761
            %
            % model degree: 8, alluvial id 2, best next-alluvial id 5, best sim 0.992126  <=
            % model degree: 8, alluvial id 3, best next-alluvial id 8, best sim 0.972389  <=
            % model degree: 8, alluvial id 11, best next-alluvial id 11, best sim 0.972525
            % model degree: 8, alluvial id 13, best next-alluvial id 13, best sim 0.993593
            % model degree: 8, alluvial id 15, best next-alluvial id 6, best sim 0.990697  <=
            % model degree: 8, alluvial id 16, best next-alluvial id 16, best sim 0.980674
            % model degree: 8, alluvial id 20, best next-alluvial id 20, best sim 0.985872
            % model degree: 8, alluvial id 24, best next-alluvial id 24, best sim 0.990014
            %
            % model degree: 10, alluvial id 4, best next-alluvial id 18, best sim 0.990785  <=
            % model degree: 10, alluvial id 5, best next-alluvial id 5, best sim 0.995395
            % model degree: 10, alluvial id 6, best next-alluvial id 6, best sim 0.991111
            % model degree: 10, alluvial id 8, best next-alluvial id 8, best sim 0.984516
            % model degree: 10, alluvial id 9, best next-alluvial id 9, best sim 0.995649
            % model degree: 10, alluvial id 11, best next-alluvial id 11, best sim 0.994069
            % model degree: 10, alluvial id 13, best next-alluvial id 13, best sim 0.995966
            % model degree: 10, alluvial id 16, best next-alluvial id 16, best sim 0.996291
            % model degree: 10, alluvial id 20, best next-alluvial id 20, best sim 0.994727
            % model degree: 10, alluvial id 24, best next-alluvial id 24, best sim 0.993142
            %
            % model degree: 12, alluvial id 4, best next-alluvial id 14, best sim 0.959376  <=
            % model degree: 12, alluvial id 5, best next-alluvial id 2, best sim 0.987929  <=
            % model degree: 12, alluvial id 6, best next-alluvial id 6, best sim 0.983694
            % model degree: 12, alluvial id 8, best next-alluvial id 8, best sim 0.991612
            % model degree: 12, alluvial id 9, best next-alluvial id 9, best sim 0.97357
            % model degree: 12, alluvial id 11, best next-alluvial id 11, best sim 0.985669
            % model degree: 12, alluvial id 13, best next-alluvial id 13, best sim 0.99485
            % model degree: 12, alluvial id 16, best next-alluvial id 16, best sim 0.99596
            % model degree: 12, alluvial id 18, best next-alluvial id 4, best sim 0.993759  <=
            % model degree: 12, alluvial id 20, best next-alluvial id 20, best sim 0.991975
            % model degree: 12, alluvial id 22, best next-alluvial id 17, best sim 0.992946  <=
            % model degree: 12, alluvial id 24, best next-alluvial id 24, best sim 0.978966
            %
            % model degree: 14, alluvial id 2, best next-alluvial id 2, best sim 0.974313
            % model degree: 14, alluvial id 3, best next-alluvial id 3, best sim 0.976274
            % model degree: 14, alluvial id 4, best next-alluvial id 18, best sim 0.9694  <=
            % model degree: 14, alluvial id 5, best next-alluvial id 5, best sim 0.972536 
            % model degree: 14, alluvial id 6, best next-alluvial id 15, best sim 0.962829  <=
            % model degree: 14, alluvial id 8, best next-alluvial id 8, best sim 0.974189
            % model degree: 14, alluvial id 9, best next-alluvial id 9, best sim 0.97552
            % model degree: 14, alluvial id 11, best next-alluvial id 11, best sim 0.972337
            % model degree: 14, alluvial id 13, best next-alluvial id 13, best sim 0.97208
            % model degree: 14, alluvial id 14, best next-alluvial id 14, best sim 0.972822
            % model degree: 14, alluvial id 16, best next-alluvial id 16, best sim 0.972373
            % model degree: 14, alluvial id 17, best next-alluvial id 17, best sim 0.966144
            % model degree: 14, alluvial id 20, best next-alluvial id 20, best sim 0.958671
            % model degree: 14, alluvial id 24, best next-alluvial id 24, best sim 0.968645
            %
            % ans =
            %
            %   6×1 cell array
            %
            %     { 2×6  double}
            %     { 6×8  double}
            %     { 8×10 double}
            %     {10×12 double}
            %     {12×14 double}
            %     {14×24 double}

            bin_mask = logical(this.mask);
            model_degrees = [2, 6, 8, 10, 12, 14, 24];

            sim_1 = cell(numel(model_degrees) - 1, 1);  % cells of models ~ {m_2, m_6, ..., m_24}
            md_idx = 0;
            for model_degree = model_degrees(1:end-1)
                md_idx = md_idx + 1;

                nodes = this.patterns2logp(num_bases=model_degree, do_checks=true);
                % fprintf("%s:  view nodes of %i-model\n", stackstr(), model_degree);
                % nodes.view()

                nodes_next = this.patterns2logp(num_bases=model_degrees(md_idx+1), do_checks=true);
                % fprintf("%s:  view nodes of %i-model\n", stackstr(), model_degrees(md_idx+1));
                % nodes_next.view()
                
                % use interpretable alluvial IDs p1, ..., p24, with "hue" colormapping
                aids = this.model_degree_to_alluvial_ids(model_degree);
                next_aids = this.model_degree_to_alluvial_ids(model_degrees(md_idx+1));

                sim_2 = nan(model_degree, model_degrees(md_idx+1));  % matrix of similarities:  model_m -> mode_{m+1}
                for node_index = 1:model_degree
                    node = nodes.imagingFormat.img(:,:,:,node_index);
                    node = asrow(node(bin_mask));
                    
                    for node_next_index = 1:model_degrees(md_idx+1)
                        node_next = nodes_next.imagingFormat.img(:,:,:,node_next_index);
                        node_next = asrow(node_next(bin_mask));
                        
                        sim_2(node_index, node_next_index) = this.cosine_similarity([node; node_next]);
                    end
                    [best_sim, best_idx] = max(sim_2(node_index, :), [], 2);
                    fprintf("model degree: %g, alluvial id %i, best next-alluvial id %i, best sim %g\n", ...
                        model_degree, aids(node_index), next_aids(best_idx), best_sim);
                end
                
                sim_1{md_idx} = sim_2;
            end

            %T = table();
        end




        function this = Topology(varargin)
            this.nmfh_ = mladni.NMFHierarchies(varargin{:});
        end
    end

    methods (Static)
    end

    %% PRIVATE

    properties (Access = private)
        mask_
        nmfh_
        pattern_probabilities_
    end

    methods % (Access = private)
        function check_sum_max(~, obj)
            ic = mlfourd.ImagingContext2(obj);
            all_ifc = ic.imagingFormat;

            fprintf("%s: checking pattern sums\n", stackstr());
            for t = 1:size(all_ifc, 4)
                img = all_ifc.img(:,:,:,t);
                img = img(isfinite(img));
                fprintf("sum_%i:  %g\n", t, sum(img, "all")); 
            end
            fprintf("sum_all:  %g\n", sum(all_ifc.img, "all"));

            fprintf("%s: checking pattern maxes\n", stackstr());
            for t = 1:size(all_ifc, 4)
                img = all_ifc.img(:,:,:,t);
                img = img(isfinite(img));
                fprintf("max_%i:  %g\n", t, max(img, [], "all")); 
            end
            fprintf("max_all:  %g\n", max(all_ifc.img, [], "all"));
        end

        function sim = cosine_similarity(~, A)
            sim = 1 - pdist(A, 'cosine');
        end

        function out = flirt(~, in)
            flirt = fullfile(getenv("FSLDIR"), "bin", "flirt");
            out = myfileprefix(in) + "_1mm.nii.gz";
            init = "/Volumes/PrecunealSSD/Singularity/ADNI/NMF_FDG/baseline_cn/NumBases24/OPNMF/niiImg/MNI152_T1_2mm_on_1mm.mat";
            ref = "/Volumes/PrecunealSSD/Singularity/ADNI/NMF_FDG/baseline_cn/NumBases24/OPNMF/niiImg/MNI152_T1_1mm.nii.gz";
            cmd = sprintf("%s -in %s -applyxfm -init %s -out %s -paddingsize 0.0 -interp spline -ref %s", ...
                flirt, in, init, out, ref);
            system(cmd)
        end

        function combinations = generate_ordered_combinations(this, num_bases, num_simplices, opts)
            arguments
                this mladni.Topology  %#ok<INUSA>
                num_bases {mustBeInteger}
                num_simplices {mustBeInteger}
                opts.maxCombinations {mustBeNumeric} = 1e6
            end

            % Calculate total possible combinations
            totalCombinations = nchoosek(num_bases, num_simplices);
            numToGenerate = min(totalCombinations, opts.maxCombinations);

            % Initialize result matrix
            combinations = zeros(numToGenerate, num_simplices);

            if totalCombinations <= opts.maxCombinations
                % Generate all combinations
                combinations(1,:) = 1:num_simplices;
                for i = 2:numToGenerate
                    current = combinations(i-1,:);
                    j = num_simplices;
                    while j >= 1 && current(j) == num_bases - num_simplices + j
                        j = j - 1;
                    end
                    current(j) = current(j) + 1;
                    for k = j+1:num_simplices
                        current(k) = current(j) + k - j;
                    end
                    combinations(i,:) = current;
                end
            else
                % Use reservoir sampling for uniform random selection
                % Initialize the reservoir with the first combination
                combinations(1,:) = 1:num_simplices;

                % Current combination
                current = combinations(1,:);

                % Counter for combinations seen
                seen = 1;

                % Process each combination using reservoir sampling
                while seen < totalCombinations
                    % Generate next combination
                    j = num_simplices;
                    while j >= 1 && current(j) == num_bases - num_simplices + j
                        j = j - 1;
                    end
                    current(j) = current(j) + 1;
                    for k = j+1:num_simplices
                        current(k) = current(j) + k - j;
                    end

                    % Increment counter
                    seen = seen + 1;

                    % Reservoir sampling logic
                    if seen <= opts.maxCombinations
                        combinations(seen,:) = current;
                    else
                        % Randomly decide whether to include this combination
                        r = randi(seen);
                        if r <= opts.maxCombinations
                            combinations(r,:) = current;
                        end
                    end
                end
            end
        end

        function combis = generate_ordered_combinations_expensive(~, num_bases, num_simplices)

            if num_bases == num_simplices
                combis = 1:num_bases;
                return
            end

            % Initialize with empty array
            combis = zeros(nchoosek(num_bases, num_simplices), num_simplices);

            % Counter for current row
            row = 1;

            % Use recursive helper function
            generate_helper([], 1, row);

            % Nested helper function to build combinations
            function r = generate_helper(current, start, r)
                % If we've selected M indices, add this combination
                if length(current) == num_simplices
                    combis(r,:) = current;
                    r = r + 1;
                    return;
                end

                % Try each possible next index
                for i = start:num_bases
                    r = generate_helper([current, i], i+1, r);
                end
            end
        end

        function h = heatmap(this, A, opts)
            %B = B(2:end,:); % leave off intercept which can be large valued

            arguments
                this mladni.Topology
                A double
                opts.labels {mustBeText} = ""
            end
            assert(size(A, 1) == size(A, 2))
            rank_model = size(A, 1);
            colormap_ = cividis(1024);

            if opts.labels == ""
                opts.labels = "p" + (1:rank_model);
            end

            h = figure;
            tiledlayout(4, 3);

            nexttile(1, [3, 3]);
            heatmap(A, ...
                XData=opts.labels, YData=opts.labels, ...
                CellLabelFormat='%0.2g', ...
                Colormap=colormap_, ...
                ColorScaling='scaled', ...
                FontSize=14);
            h.Colormap = colormap_;
            ylabel('Patterns');
            xlabel('Patterns');
            if rank_model >= 12
                title(sprintf('Overlaps of %i patterns in model space (encoding/mm^3)', rank_model));
            else
                title("Overlaps of " + rank_model)
            end

            nexttile(10, [1, 3]);
            marginals = sum(A, 1, "omitmissing");
            bar(opts.labels, marginals, FaceColor=colormap_(341,:));
            ylabel("Marginal overlap");
        end

        function edges = node2edges(this, nodes, opts)
            %% returns edges:  log P(nodes_next, nodes(node_index))

            arguments
                this mladni.Topology
                nodes mlfourd.ImagingContext2 {mustBeNonempty}
                opts.node_index double = 1
                opts.nodes_next mlfourd.ImagingContext2 {mustBeNonempty}
            end
            
            node = nodes.imagingFormat;
            node.img = node.img(:,:,:, opts.node_index);

            nodes_next = opts.nodes_next.imagingFormat;

            edges = copy(nodes_next);
            Nedges = size(nodes_next, 4);
            for e = 1:Nedges
                edges.img(:,:,:,e) = node.img + nodes_next.img(:,:,:,e);
            end
            edges.fileprefix = nodes.fileprefix + "_node" + opts.node_index + "to" + Nedges + "edges";
        end

        function ids = model_degree_to_alluvial_ids(~, model_degree)
            switch model_degree
                case 2
                    ids = [11,20];
                case 6
                    ids = [3,11,13,15,16,20];
                case 8
                    ids = [2,3,11,13,15,16,20,24];
                case 10
                    ids = [4,5,6,8,9,11,13,16,20,24];
                case 12
                    ids = [4,5,6,8,9,11,13,16,18,20,22,24];
                case 14
                    ids = [2,3,4,5,6,8,9,11,13,14,16,17,20,24];
                case 24
                    ids = 1:24;
                otherwise
                    error("mladni:ValueError", stackstr())
            end
        end

        function sampledMatrix = random_sample_rows(~, matrix, numSamples)
            % Get the number of rows in the original matrix
            [M, ~] = size(matrix);

            % Determine number of rows to sample (either numSamples or all rows if M is smaller)
            numSamples = min(numSamples, M);

            % Generate random row indices without replacement
            randomIndices = randperm(M, numSamples);

            % Extract the randomly selected rows
            sampledMatrix = matrix(randomIndices, :);
        end

        function set_gcf(this, opts)
            arguments
                this mladni.Topology
                opts.fracx double = 1
                opts.Npx double = 1400
                opts.fracy double = 0.9236
                opts.Npy double = 1400
            end
            set(gcf, Position=[1 1 opts.fracx*opts.Npx opts.fracy*opts.Npy])
        end
    end
    
    %  Created with mlsystem.Newcl, inspired by Frank Gonzalez-Morphy's newfcn.
end
